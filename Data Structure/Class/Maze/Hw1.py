# ******************************************************
# * Name: 김영훈
# * Student ID: 20171597
# * Program ID: Homework #1 <Miro>
# * Description: Stack 자료 구조를 이용하여 주어진 미로의 출구를 찾는다.
# * Algorithm: 기본적인 동작은 모든 위치가 행과 열(행, 열)로 이루어진 미로를 탐색하는데,
# * 미리 정의된 출구의 행열 값과 현재 위치의 값이 다르다면 출구를 찾을 때까지 반복하면서 미로를 탐색한다.
# * 길을 찾을 때는 사전에 정의된 이동 테이블에 따라서 N, NE, E, SE, S, SW, W, NW 방향의 순서대로 길을 찾는데,
# * 예를 들어서, N 방향의 값이 1일 경우, 주어진 테이블의 순서에 따라 NE 를 그 다음에는 E, SE, S.. 이런식으로 순차탐색을 한다.
# * 만약 해당 방향의 값이 0일 경우 현재 위치를 해당 위치로 이동하고, 스택에 이동하기 전 위치 값을 Push 한다.
# * 모든 방향의 값이 1, 즉 벽으로 막혀있는 경우에는 스택에 마지막으로 저장된 값을 Pop 시켜서 이동 전 위치로 돌아간 후
# * 다시 해당 값으로 테이블에 따라 길을 찾는 과정을 반복 한다.
# * 최종적으로 출구 값에 해당하는 위치를 찾았을 경우, 탐색 과정(mark)과 경로(path)에 대한 순서를 출력하고 프로그램을 종료한다.
# * Variables: < Hw1_Stack.py >
# * is_full() : 스택이 가득 찼는지 확인한다.
# * is_empty() : 스택이 비어있는지 확인한다.
# * push(data) : 스택에 data 값을 저장한다.
# * pop() : 스택에 마지막으로 저장된 값을 꺼낸다.
# * display_stack() : 스택에 저장된 값을 마지막으로 저장된 것부터 순서대로 출력한다.
# * display_stack_reverse(row, col) : 스택에 저장된 값을 입력된 순서대로 출력한다.
# * (스택은 LIFO 구조이지만 미로 경로의 순서를 보기 편하게 출력하기 위함이다.)
# * top(variable) : 스택의 맨 위를 가리키는 값이다.
# * stackSize(variable) : 스택의 사이즈를 지정하기 위한 변수이다.
# * stack : 실제 데이터가 저장되는 스택이다.
# * < Hw1.py >
# * namedtuple : 변수들을 묶어서 값을 지정할 수 있도록 해주고 인덱스로 접근이 가능하도록 한다. (C 계열 언어의 구조체와 비슷한 동작을 한다. )
# ******************************************************

# Stack 함수가 저장되어있는 Hw1_Stack.py 파일을 import 한다.
import HW.Hw1_Stack as Stack
# 이동 테이블에 속한 변수들을 묶어서 정의 하기위해 namedtuple 을 import 한다.
from collections import namedtuple

# 미로 출구를 찾았는지 판별하기 위해서 flag 변수로서 found 를 선언한다.
found = False

# 미로 맵과 이동 흔적에 대한 mark
# 0 ~ 16 X 0 ~ 13
maze = [
#0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 0
[1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], # 1
[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], # 2
[1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1], # 3
[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], # 4
[1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], # 5
[1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], # 6
[1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], # 7
[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], # 8
[1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], # 9
[1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1], # 10
[1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1], # 11
[1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1], # 12
[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]  # 13
]

# 같은 사이즈로 정의
mark = [
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
]

# 이동 테이블을 선언 한다. (인덱스 접근 가능)
direction = namedtuple("direction", "N NE E SE S SW W NW")
move_vert = direction(-1, -1, 0, 1, 1, 1, 0, -1)
move_horiz = direction(0, 1, 1, 1, 0, -1, -1, -1)

# ******************************************************
# * function: is_full
# * description: is_full 함수의 사용 목적은 스택을 사용하기 전 스택 공간이 제대로 확보 되었는지의 여부를 확인하기 위함이다.
# * variable: top 으로 스택의 맨 위를 지정하도록 한다. (-1일 경우 스택이 비어있음)
# *           stackSize 는 스택의 전체 공간을 가리키는 변수이다.
# ******************************************************
if Stack.is_full():
    print("Stack is full !")
else:
    mark[1][1] = 1
    Stack.push([1, 1])

# 초기 값을 지정한다.
# 이때, (1, 1) 은 사전에 Push 했으므로 이전 값에 대한 중복 Push 를 방지하기 위해 다음 위치를 초기 값으로 설정한다.
i = 2; j = 2; d = 0
# 출구 값을 지정한다.
exit_row = 12
exit_col = 15
# 출력을 위한 mark 로그를 기록한다.
mark_log = [[1, 1]]

while(Stack.top > -1 and (not found)):
    # 이동 테이블의 모든 방향이 막혔을 경우
    if d > 7:
        print("Log: 길이 막혔습니다. Pop을 수행하겠습니다.")
        # ******************************************************
        # * function: pop
        # * description: pop 함수의 사용 목적은 스택으로부터 마지막에 저장된 값을 빼내고 위치 값을 돌려받기 위함이다.
        # * variable: 마찬가지로 top 변수를 사용하며, stack 값을 리턴하고 top 이 가리키는 위치를 1만큼 낮춘다.
        # ******************************************************
        i, j = Stack.pop()
        print("Event(POP) :: [%d][%d]" % (i, j))
        d = 0

    while(d < 8 and (not found)):
        # 이동 테이블에 따라 다음 이동 좌표 지정한다.
        g = i + move_vert[d]
        h = j + move_horiz[d]

        print("Log: 다음 미로 검사 대상 좌표는 [%d][%d] 입니다." %(g, h))

        # 출구 값과 동일할 경우, 즉 출구 값을 찾았을 때
        if g == exit_row and h == exit_col:
            found = True
            # 경로 출력
            print("END :: 길을 찾았습니다 !!")
            print("END :: 출구는 [%d][%d] 에 존재합니다." % (g, h))
            print("Log: 미로의 길을 알려주는 경로를 순서대로 출력하겠습니다.")

        # 새로운 길 발견 or 미로 결과 출력을 위한 마지막 이전 값 Push
        if (not maze[g][h]) and (not mark[g][h]):
            mark[g][h] = 1
            # ******************************************************
            # * function: push
            # * description: push 함수의 사용 목적은 스택에 위치 값을 저장하기 위함이다.
            # * variable: data 변수로 위치 값을 입력으로 받아서 스택에 저장하고 top 값을 1만큼 증가시킨다.
            # ******************************************************
            Stack.push([i, j])
            print("Event(PUSH) :: [%d %d]" % (i, j))
            tmp_i = i
            tmp_j = j
            i = g; j = h; d = 0

            # 최종 미로 결과 출력 (중복 로그 방지를 위한 조건문)
            if i == 12 and j == 15 and found:
                print("<<<<<<<<<<<<<<<< Result >>>>>>>>>>>>>>>>>>")
                print("Path: ", end=' ')
                # ******************************************************
                # * function: display_stack_reverse
                # * description: 이 함수의 사용 목적은 미로 찾기 결과로 출력될 미로의 경로를 사람이 보기 편리하게 출력해주기 위함이다.
                # * variable: top 변수는 임의로 변경할 수 없기 때문에, 대신 sp 변수를 사용하여 제일 바닥에 있는 값부터 마지막 값까지 위치를 증가한다.
                # ******************************************************
                Stack.display_stack_reverse(g, h)
                print("========================================")
                # Mark (이동 흔적을 출력)
                print("Mark: ", end=' ')
                for list in mark_log:
                    print(list, end=' -> ')
                print([g, h])
            else:
                print("Log: 새로운 길을 찾았으며 다음으로 넘어가겠습니다.")
                print("Log: 이전 좌표는 [%d][%d]이며, 다음 좌표는 [%d][%d] 입니다." % (tmp_i, tmp_j, i, j))
                mark_log.append([i, j])

        else:
            d += 1
            print("Log: 길이 없으므로 방향을 바꿉니다. 현재 d의 값은 %d 입니다." % d)
